import { Injectable, Logger } from '@nestjs/common';
import { ScannerType, DEFAULT_SCANNER_TYPE } from '../enums/scanner-type.enum';
import { IssueImpact } from '../enums/issue-impact.enum';
import { RuleResponseDto } from '../dto/scan-response.dto';
import { RuleServiceFactory } from './rule-service-factory.service';
import { Language } from '../types/language.types';
import { importRules } from 'kayle';

/**
 * Rule describing a scanner rule with metadata from Kayle.
 * This interface represents the structure returned by Kayle's importRules function.
 */
interface KayleRule {
  ruleId: string;
  description?: string;
  help?: string;
  helpUrl?: string | string[];
  tags?: string[];
  actIds?: string[];
  ruleType?: 'error' | 'warning' | 'notice';
}

/**
 * Service for retrieving and managing accessibility scanner rules.
 * 
 * This service provides access to all available accessibility rules for
 * different scanner types (HTMLCS, Axe) using Kayle's importRules function.
 * It transforms the raw rule data into the application's RuleResponseDto format
 * with appropriate help URLs and impact levels.
 * 
 * Key features:
 * - Dynamic rule loading from Kayle for both HTMLCS and Axe scanners
 * - Multi-language support for rule descriptions
 * - Consistent rule metadata formatting across scanner types
 * - Help URL generation using scanner-specific rule services
 * - Impact level mapping from Kayle rule types
 */
@Injectable()
export class RulesService {
  private readonly logger = new Logger(RulesService.name);

  constructor(private readonly ruleServiceFactory: RuleServiceFactory) {}

  /**
   * Retrieves all available rules for a specific scanner type.
   * 
   * This method uses Kayle's importRules function to dynamically load
   * rule definitions for the specified scanner and language. Rules are
   * transformed into the application's standard RuleResponseDto format
   * with help URLs generated by the appropriate rule service.
   * 
   * @param scannerType - The scanner type (HTMLCS or Axe). Defaults to HTMLCS if not specified.
   * @param language - Language code for rule descriptions (defaults to 'en')
   * @returns Promise resolving to array of rule response DTOs
   * @throws {Error} When rule loading fails or scanner type is unsupported
   */
  async getRulesForScanner(
    scannerType?: ScannerType,
    language: Language = 'en',
  ): Promise<RuleResponseDto[]> {
    // Use default scanner type if not specified
    const effectiveScannerType = scannerType || DEFAULT_SCANNER_TYPE;
    
    this.logger.log(`Loading rules for scanner: ${effectiveScannerType}, language: ${language}`);

    try {
      // Map scanner type to Kayle runner name
      const runnerName = this.mapScannerTypeToRunner(effectiveScannerType);
      
      // Load rules from Kayle
      const kayleRules: KayleRule[] = await importRules(language, runnerName);
      
      this.logger.log(`Loaded ${kayleRules.length} rules for ${effectiveScannerType}`);

      // Get the appropriate rule service for URL generation
      const ruleService = this.ruleServiceFactory.getRuleService(effectiveScannerType);

      // Transform Kayle rules to RuleResponseDto format
      const rules = kayleRules.map((kayleRule) => this.transformKayleRule(kayleRule, ruleService));

      // Sort rules by ID for consistent ordering
      rules.sort((a, b) => a.id.localeCompare(b.id));

      return rules;
    } catch (error) {
      this.logger.error(`Failed to load rules for scanner ${effectiveScannerType}:`, error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      throw new Error(`Failed to load rules for scanner ${effectiveScannerType}: ${errorMessage}`);
    }
  }

  /**
   * Maps application scanner types to Kayle runner names.
   * 
   * @param scannerType - Application scanner type
   * @returns Kayle runner name
   * @throws {Error} For unsupported scanner types
   */
  private mapScannerTypeToRunner(scannerType: ScannerType): 'htmlcs' | 'axe' {
    switch (scannerType) {
      case ScannerType.HTMLCS:
        return 'htmlcs';
      case ScannerType.AXE:
        return 'axe';
      default:
        throw new Error(`Unsupported scanner type: ${scannerType}`);
    }
  }

  /**
   * Transforms a Kayle rule object into the application's RuleResponseDto format.
   * 
   * This method converts Kayle's rule structure into the standardized format
   * used throughout the application, including help URL generation and
   * impact level mapping.
   * 
   * @param kayleRule - Raw rule object from Kayle
   * @param ruleService - Rule service for generating help URLs
   * @returns Transformed rule response DTO
   */
  private transformKayleRule(
    kayleRule: KayleRule,
    ruleService: any,
  ): RuleResponseDto {
    return {
      id: kayleRule.ruleId,
      description: kayleRule.description || kayleRule.help || `Rule: ${kayleRule.ruleId}`,
      impact: this.mapRuleTypeToImpact(kayleRule.ruleType),
      urls: ruleService.getHelpUrls(kayleRule.ruleId),
    };
  }

  /**
   * Maps Kayle rule types to application impact levels.
   * 
   * @param ruleType - Kayle rule type
   * @returns Application impact level
   */
  private mapRuleTypeToImpact(ruleType?: string): IssueImpact {
    switch (ruleType) {
      case 'error':
        return IssueImpact.ERROR;
      case 'warning':
        return IssueImpact.WARNING;
      case 'notice':
        return IssueImpact.NOTICE;
      default:
        // Default to ERROR for unknown rule types to ensure attention
        return IssueImpact.ERROR;
    }
  }
}
